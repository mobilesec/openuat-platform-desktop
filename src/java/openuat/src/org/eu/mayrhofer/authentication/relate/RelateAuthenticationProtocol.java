/* Copyright Rene Mayrhofer
 * File created 2005-09
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */
package org.eu.mayrhofer.authentication.relate;

import org.eu.mayrhofer.authentication.AuthenticationEventSender;
import org.eu.mayrhofer.authentication.AuthenticationProgressHandler;
import org.eu.mayrhofer.authentication.DHOverTCPWithVerification;
import org.eu.mayrhofer.authentication.HostProtocolHandler;
import org.eu.mayrhofer.authentication.exceptions.*;

import java.io.*;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;
//import java.util.Arrays;
import java.util.Iterator;

import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;

import uk.ac.lancs.relate.core.MeasurementQueue;
import uk.ac.lancs.relate.core.SerialConnector;
import uk.ac.lancs.relate.core.DongleException;
import uk.ac.lancs.relate.core.Measurement;
import uk.ac.lancs.relate.core.MeasurementManager;
import uk.ac.lancs.relate.core.EventDispatcher;
import uk.ac.lancs.relate.auth.ProgressEventHandler;
//import uk.ac.lancs.relate.events.RelateEvent;
//import uk.ac.lancs.relate.core.MessageQueue;

/** This is the main class of the relate authentication software: it ties together
 * the host and dongle protocol handlers. Since both handlers work asynchronously
 * in their own threads, this class must also handle the synchronisation between 
 * all events coming in from them.
 * 
 * It can generate two types of events of its own: as a subclass of AuthenticationEventSender, it
 * sende AuthenticationEvents to all registered AuthenticationProgressHandler. Additionally, when
 * a ProgressEventHandler object is given to the constructor, it will generate the more specific
 * relate events.
 * 
 * The authentication success event generated by this protocol will return an
 * object array consisting of an InetAddress object and an Integer object for the
 * remote parameter and either a byte or an object array as the result parameter.
 * For the remote parameter, the first object (InetAddress) represents the remote host
 * address, while the second object (Integer) represents the remote Relate id.
 * The result parameter will contain only the session key as a byte array when 
 * keepSocketConnected has been set to false in the constructor, but will contain
 * an Object array with the session key (again as a byte array) as its first entry
 * and the TCP Socket object as its second entry when keepSocketConnected has been 
 * set to true.
 * 
 * The authentication failure and progress events to not go to these lengths and will
 * return either an InetAddress object or an Integer object as the remote parameter,
 * depending on the current stage of the Relate protocol when the event occurs.
 * 
 * @author Rene Mayrhofer
 * @version 1.0
 */
public class RelateAuthenticationProtocol extends DHOverTCPWithVerification {
	/** Our log4j logger. */
	private static Logger logger = Logger.getLogger(RelateAuthenticationProtocol.class);
	/** This is a special log4j logger used for logging only statistics. It is separate from the main logger
	 * so that it's possible to turn statistics on an off independently.
	 */
	private static Logger statisticsLogger = Logger.getLogger("statistics.relateauthentication");

	public static final int TcpPort = 54321;
	
	// TODO: remove me now that it should be simple to implement a dummy protocol that works like this
	// class with simulation = true
	/** If set to true, then all the code will run without communicating with a dongle. This is helpful
	 * for simulation the authentication without the actual dongle. It can be used for debugging and
	 * testing.
	 */
	private static boolean simulation = false;
	
	/** The serial port that is used by this authentication protocol instance to connect to its dongle. */
	private String serialPort;
	
	/** The measurement manager object which listens for measurments coming from the used serial port.
	 * It will be used to fetch the reference measurement.
	 * @see #referenceMeasurement
	 */
	private MeasurementManager manager;
	
	/** This is just a helper to hold the remoteRelateId that is passed to startAuthentication
	 * until it is needed when starting the DongleProtocolHandler (after the HostProtocolHandler
	 * has finished successfully). When set to -1, this indicates "server" mode where the remote
	 * relate id is taken from the optionalParameter of the HostAuthenticationSuccess event. When
	 * not -1, this indicates "client" mode and this id will be taken.
	 * @see #startAuthentication
	 * @see HostAuthenticationEventHandler
	 */
	private int remoteRelateId = -1;

	/** The number of rounds used for the spatial authentication protocol. This is used to remember
	 * th enumber of rounds that is agreed to when phase 1 finished, so that it can be access in
	 * phase 2. It will only be valid during a running verification phase and will be set to -1
	 * at any other time.
	 */
	private int rounds = -1;
	
	/** AuthenticationProgressEvents will be forwarded to this more Relate-specific handler, when
	 * set != null. It is a second possibility for this class to fire events, in addition to the
	 * methods offered by AuthenticationEventSender.
	 */
	private ProgressEventHandler relateEventHandler = null;
	
	/** The reference measurement to the remoteRelateId device taken when the
	 * user selected this device for authentication, or the last one taken 
	 * before the authentication request came in on the server end.
	 * <br>
	 * This measurement is taken from the MeasurementManager (which records past
	 * measurements) and stored when startAuthentication is called (i.e. an
	 * "outgoing" authentication is being initialized) or when an incoming
	 * host authentication has succeeded (i.e. an "incoming" authentication is
	 * being initialized).
	 * 
	 * @see #startAuthentication for the "outgoing" authentication
	 * @see HostAuthenticationEventHandler#AuthenticationSuccess(Object, Object, Object) for the "incoming" authentication
	 * @see #fetchReferenceMeasurement is the helper method used for both incoming and outgoing
	 */
	private int referenceMeasurement = -1;
	
	/** This is only a helper to get the reference measurement now - pending better integration
	 * with the Relate framework.
	 * @param remoteRelateId
	 * @return
	 */
	/*private static int helper_getReferenceMeasurement(String serialPort, byte remoteRelateId) throws ConfigurationErrorException, InternalApplicationException {
		int referenceMeasurement;
		SerialConnector serialConn;
		
		// immediately get the reference measurement to the specific remote relate dongle
		try {
			// Connect here to the dongle so that we don't block it when not necessary. This needs better integration with the Relate framework. 
			serialConn = SerialConnector.getSerialConnector(serialPort);
			logger.info("-------- connected successfully to dongle at port " + serialPort + ", including first handshake. My ID is " + serialConn.getLocalRelateId());
		}
		catch (DongleException e) {
			logger.error("-------- failed to connect to dongle at port " + serialPort + ", didn't get my ID.");
			throw new ConfigurationErrorException("Can't connect to dongle.", e);
		}
		
		int localRelateId = serialConn.getLocalRelateId();
		if (localRelateId == -1)
			throw new InternalApplicationException("Dongle at port " + serialPort + " reports id -1, which is an error case.");
		
		// start the backgroud thread for getting messages from the dongle
		serialConn.start();
		
		// This message queue is used to receive events from the dongle, in this case the reference measurements.
		MessageQueue eventQueue = new MessageQueue();
		serialConn.registerEventQueue(eventQueue);

		// test code begin
		class ThreeInts { public long sum = 0, n = 0, sum2 = 0; };
		ThreeInts[] s = new ThreeInts[256]; for(int i=0; i<256; i++) s[i] = new ThreeInts();
		// test code end
		
		// wait for the first reference measurements to come in (needed to compute the delays)
		logger.debug("Trying to get reference measurement from local id " + localRelateId + " at port " + serialPort + " to relate id " + remoteRelateId);
		int[] ref = new int[10];
		int numMeasurements = 0;
		while (numMeasurements < 10) {
			while (eventQueue.isEmpty())
				eventQueue.waitForMessage(500);
			RelateEvent e = (RelateEvent) eventQueue.getMessage();
			if (e == null) {
				logger.warn("Warning: got null message out of message queue at port " + serialPort + "! This should not happen.");
				continue;
			}
			
			// test code begin
			if (e instanceof MeasurementEvent && ((MeasurementEvent) e).getDongleId() == localRelateId) {
				MeasurementEvent me = (MeasurementEvent) e;
				
				if (/*me.getMeasurement().getTransducers() != 0 &&*/ 
/*				me.getMeasurement().getDistance() != 4094) {
					logger.debug("Got local measurement from dongle " + me.getDongleId() + " at port " + serialPort + " to dongle " + me.getMeasurement().getRelatumId() + ": " + me.getMeasurement().getDistance());
					ThreeInts x = s[me.getMeasurement().getRelatumId()];
					x.n++;
					x.sum += me.getMeasurement().getDistance();
					x.sum2 += me.getMeasurement().getDistance() * me.getMeasurement().getDistance();
					logger.debug("To dongle " + me.getMeasurement().getRelatumId() + ": mean=" + (float) x.sum/x.n + ", variance=" + 
							Math.sqrt((x.sum2 - 2*(float) x.sum/x.n*x.sum + (float) x.sum/x.n*x.sum)/x.n) );
				}
				else {
					logger.debug("Discarded invalid local measurement from dongle " + me.getDongleId() + " to dongle " + me.getMeasurement().getRelatumId() + ": " + me.getMeasurement().getDistance());
				}
			}
			// test code end
			
			if (e instanceof MeasurementEvent && ((MeasurementEvent) e).getMeasurement().getDongleId() == localRelateId &&  
					((MeasurementEvent) e).getMeasurement().getRelatumId() == remoteRelateId && ((MeasurementEvent) e).getMeasurement().getTransducers() != 0 && ((MeasurementEvent) e).getMeasurement().getDistance() != 4094) {
				MeasurementEvent me = (MeasurementEvent) e;

				logger.info("Received reference measurement from dongle " + localRelateId + " at port " + serialPort + " to dongle " + remoteRelateId + ": " + me.getMeasurement().getDistance());
				ref[numMeasurements++] = me.getMeasurement().getDistance();
			}
		}
		Arrays.sort(ref);
		referenceMeasurement = (ref[4] + ref[5]) / 2;
		logger.info("Mean over reference measurements from dongle " + localRelateId + " at port " + serialPort + " to dongle " + remoteRelateId + ": " + referenceMeasurement);
		
		serialConn.unregisterEventQueue(eventQueue);
		
		return referenceMeasurement;
	}*/
	
	/** Initialized the authentication object with the contact data of the remote device to authenticate with.
	 * This constructor also gets a reference measurement to the remote relate id by itself. This needs better
	 * integration with the Relate framework, the reference measurement should come from "the outside".
	 * 
	 * @param serialPort The serial port to which the dongle is connected
	 * @param manager The measurement manager to use. This manager should be registered at the dongle 
	 *                that is connected to serialPort and should keep a history of the last measurement
	 *                received locally from this dongle. It will be used by RelateAuthenticationProtocol
	 *                to fetch the reference measurement before starting the spatial authentication 
	 *                protocol.
	 * @param useJSSE If set to true, the JSSE API with the default JCE provider of the JVM will be used
	 *                for cryptographic operations. If set to false, an internal copy of the Bouncycastle
	 *                Lightweight API classes will be used.
	 * @param keepSocketConnected
	 *            If set to true, the opened client socket soc is passed to the
	 *            authentication success event (in the results parameter) for 
	 *            further re-use of the connection (e.g. passing additional 
	 *            information about further protocol steps). If set to false, the
	 *            socket will be closed when this protocol is done with it. The socket
	 *            will always be closed on authentication failures.
	 *            If in doubt, set to false;
	 * @param relateEventHandler If set to an object != null, it will get notified of all events.
	 */
	public RelateAuthenticationProtocol(String serialPort, MeasurementManager manager, boolean useJSSE,
				boolean keepSocketConnected, ProgressEventHandler relateEventHandler) {
		super(TcpPort, keepSocketConnected, serialPort, useJSSE);
		
		if (!simulation) {
			// when simulating, we won't have these
			this.serialPort = serialPort;
			this.manager = manager;
		}
		this.relateEventHandler = relateEventHandler;
	}
	
	/** This is only a helper method to fetch the reference measurement to a remote host from the
	 * MeasurementManager. It will block until such a measurement could be received.
	 * 
	 * @param remoteRelateId The remote relate id to get the reference measurement to.
	 * @return The reference measurement.
	 * 
	 * @see #startAuthentication for the "outgoing" authentication
	 * @see HostAuthenticationEventHandler#AuthenticationSuccess(Object, Object, Object) for the "incoming" authentication
	 */
	private int fetchReferenceMeasurement(byte remoteRelateId) {
		int ref = -1;
		while (ref == -1) {
			logger.debug("Fetching reference mesurements from dongle at port " + serialPort + " to remote id " + remoteRelateId);
			/* this gives us all the measurements that the local dongle took (i.e. where the 
			 * getDongleId() of MeasurementEvent was equal to the localRelateId) to the remote 
			 * dongle (i.e. where Measurement.getRelatumId was equal to remoteRelateId) */
			MeasurementQueue measurements = manager.getLocalMeasurementsTo(remoteRelateId);
			// simply find the first (i.e. newest) valid measurement
			Iterator iter = measurements.iterator();
			while (ref == -1 && iter.hasNext()) {
				Measurement m = (Measurement) iter.next();
				logger.debug("Examining measurement from dongle at port " + serialPort + ": " + m);
				if (m.getTransducers() > 0 && m.getDistance() < 4094) {
					ref = m.getDistance();
					logger.info("Taking reference measurement from dongle at port " + serialPort + " to remote id " + remoteRelateId + ": " + ref);
				}
			}
			if (ref == -1) { 
				// no measurements in the list yet, wait for it to happen
				logger.info("No measurement from dongle at port " + serialPort + " to remote id " + remoteRelateId + " yet. Waiting.");
				try {
					Thread.sleep(500);
				} catch (InterruptedException e) {}
			}
		}
		return ref;
	}
	
	/** Starts the spatial authentication protocol in the background. Listeners should subscribe to
	 * authentication events to get notified about the progress of authentication.
	 * @param remoteHost The hostname/IP address of the remote device to send an authentication request to.
	 * @param remoteRelateId The relate id of the remote device. This is set by the client only
	 *                       to enable stricter error checks. T
	 * @param rounds The number of rounds that should be used for the dongle authentication. This
	 * directly influences the achieved security level, as described in DongleProtocolHandler#handleDongleCommunication.
	 * 
	 * @return true if the authentication could be started, false otherwise.
	 * 
	 * @see AuthenticationEventSender#addAuthenticationProgressHandler
	 * @see DongleProtocolHandler#handleDongleCommunication
	 */
	public boolean startAuthentication(String remoteHost, byte remoteRelateId, int rounds) 
			throws UnknownHostException, IOException/*, ConfigurationErrorException, InternalApplicationException*/ {
		if (rounds < 2) {
			logger.error("Invalid number of rounds (" + rounds + "), need at least 2");
			return false;
		}
		
		/* remember the remote relate id for later to pass it to the DongleAuthenticationHandler when
		 * the HostProtocolHandler has finished successfully.
		 */	
		this.remoteRelateId = remoteRelateId;
		
		int localRelateId = -1;
		if (!simulation) {
			// this code block only gets our local relate id so that it can be transmitted to the other host
			SerialConnector serialConn;
			try {
				// Connect here to the dongle so that we don't block it when not necessary. This needs better integration with the Relate framework. 
				serialConn = SerialConnector.getSerialConnector(serialPort);
				logger.info("-------- connected successfully to dongle at port " + serialPort + ", including first handshake. My ID is " + serialConn.getLocalRelateId());
			}
			catch (DongleException e) {
				logger.error("-------- failed to connect to dongle at port " + serialPort + ", didn't get my ID.");
				// throw new ConfigurationErrorException("Can't connect to dongle.", e);
				return false;
			}
		
			localRelateId = serialConn.getLocalRelateId();
			if (localRelateId == -1)
				//throw new InternalApplicationException("Dongle reports id -1, which is an error case.");
				return false;

			/* And remember the last reference measurement taken to the remote relate id for
			 * future use (i.e. computing the delays).
			 */
			referenceMeasurement = fetchReferenceMeasurement(remoteRelateId);
		}
		else
			logger.warn("Skipping to get local relate id and reference measurement due to simulation mode");
		
		// create the optional parameter object to pass, consisting of the relate id and the number of rounds
		String param = Integer.toString(localRelateId) + " " + Integer.toString(rounds);
		if (!startAuthentication(remoteHost, param)) {
			logger.error("Could not start authentication with " + remoteHost + ", relate id " + remoteRelateId);
			return false;
		}
		else
			return true;
	}
	
	/** Called by the base class when the object is reset to idle state. */
	protected void resetHook() {
		// this needs to be reset so that the handler will be in "server" state
		remoteRelateId = -1;
		referenceMeasurement = -1;
		// also reset number of rounds
		rounds = -1;
	}
	
	/** Called by the base class when the whole authentication protocol succeeded. */
	protected void protocolSucceededHook(InetAddress remote, 
			Object optionalRemoteId, String optionalParameterFromRemote, 
			byte[] sharedSessionKey) {
		// the optionalRemoteId is set to the DongleProtocolHandler object
		DongleProtocolHandler localSide = (DongleProtocolHandler) optionalRemoteId;
		
		// in addition to the "standard" event sent by the super class, send the specialized Relate event too
		if (relateEventHandler != null)
			relateEventHandler.success(serialPort, remote.getHostAddress(), 
					remoteRelateId, (byte) rounds, sharedSessionKey);

		// and log to the statistics logger!
		if (!simulation) {
    		// first extract the values from the optional remote status string
    		String values[] = optionalParameterFromRemote.split(" ", 2);
    		// first local, than remote times
    		statisticsLogger.info("+ " + rounds + " " + referenceMeasurement + " " +
    				localSide.getSendCommandTime() + " " + localSide.getDongleInterlockTime() +
    				" " + values[0] + " " + values[1] + " Dongle authentication succeeded");
		}
	}
	
	/** Called by the base class when the whole authentication protocol failed. */
	protected void protocolFailedHook(InetAddress remote, Object optionalRemoteId, 
			Exception e, String message) {
		logger.error("Authentication protocol failed at port " + serialPort + 
				" with " + remote + "%" + optionalRemoteId + ": " + e + " / " + message);
		if (relateEventHandler != null)
			relateEventHandler.failure(serialPort, remote.toString(),
					optionalRemoteId != null ? ((Integer) optionalRemoteId).intValue() : -1,
					e, message);

		// also log that failure to the statistics logger
		statisticsLogger.error("- " + rounds + " " + referenceMeasurement + 
				" Authentication failed: '" + e + "' / '" + message + "'");
	}

	/** Called by the base class when the whole authentication protocol shows progress. */
	protected void protocolProgressHook(InetAddress remote, 
			Object optionalRemoteId, int cur, int max, String message) {
		if (relateEventHandler != null)
			relateEventHandler.progress(serialPort, remote.toString(),
				optionalRemoteId != null ? ((Integer) optionalRemoteId).intValue() : -1,
				cur, max, message);
	}
	
	/** Called by the base class when shared keys have been established and should be verified now.
	 * In this implementation, verification is done by starting a DongleAuthenticationProtocol. 
	 */
	protected void startVerification(byte[] sharedAuthenticationKey, 
			InetAddress remote, String param, Socket socketToRemote) {
		// first do some sanity checks
		if (referenceMeasurement != -1)
			logger.error("Internal inconsistency! Object is idle in server mode, but referenceMeasurement is set");
		if (remoteRelateId != -1)
			logger.error("Internal inconsistency! Object is idle in server mode, but remoteRelateId is set");
		
		logger.info("Starting key verification at port " + serialPort);

        /* extract the optional parameters (in the case of the RelateAuthenticationProtocol: the remote
        relate id to authenticate with and the number of rounds - we assume them to be set) as well as the 
        socket (which is assumed to be still connected to the remote) */
		logger.debug("Splitting received param string '" + param + "'");
		String param1 = param.substring(0, param.indexOf(' '));
		String param2 = param.substring(param.indexOf(' ')+1, param.length());
		// distinguish between client and server mode here
		byte otherRelateId;
		if (remoteRelateId != -1) {
			// "client" mode - this is the id that was passed to startAuthentication
     		otherRelateId = (byte) remoteRelateId;
     		logger.debug("Client mode at port " + serialPort + ": taking remote relate id that was passed earlier: " + otherRelateId);
		}
		else {
     		// "server" mode - take the id that was passed by the client
     		otherRelateId = Byte.parseByte(param1);
     		logger.debug("Server mode at port " + serialPort + ": taking remote relate id from authentication request message: " + otherRelateId);
 			/* And remember the last reference measurement taken to the remote relate id for
 			 * future use (i.e. computing the delays). For client mode, it has been set even
 			 * before starting the host authentication phase.
 			 */
     		if (!simulation)
     			referenceMeasurement = fetchReferenceMeasurement(otherRelateId);
     		else
     			logger.warn("Skipping to get reference measurement due to simulation mode");
		}
		rounds = Integer.parseInt(param2);
		logger.debug("Parameters for dongle authentication are now remoteId=" + 
				otherRelateId + ", rounds=" + rounds);

        if (!simulation) {
        	// and use the agreed authentication key to start the dongle authentication
        	logger.debug("Starting dongle authentication at dongle " + serialPort + " with remote relate id " + otherRelateId + " and " + rounds + " rounds.");
        	DongleProtocolHandler dh = new DongleProtocolHandler(serialPort, otherRelateId, useJSSE);
        	dh.addAuthenticationProgressHandler(new DongleAuthenticationEventHandler());
        	/* IMPORTANT NOTE: this uses the authentication key, and not the shared secret on purpose! The
        	 * authentication key is used for no other purpose, so even a problem with the protocol should
        	 * not reveal the shared secret key.
        	 */
        	dh.startAuthentication(sharedAuthenticationKey, rounds, referenceMeasurement);
        }
        else {
        	logger.warn("Skipping to start dongle authentication with " + rounds + " rounds due to simulation mode, assuming immediate authentication success");
        	new DongleAuthenticationEventHandler().AuthenticationSuccess(null, new Integer(-1), null);
        }
	}
	
	/** A helper class for handling the events from DongleProtocolHandler. These give us the final
	 * decisions and are forwarded. 
	 */
	private class DongleAuthenticationEventHandler implements AuthenticationProgressHandler {
	    public void AuthenticationSuccess(Object sender, Object remote, Object result) {
	    	if (! isVerifying()) {
	    		logger.error("Received dongle authentication success event with remote id " + remote + 
	    				" from " + sender + " while not expecting one! This event will be ignored.");
	    		return;
	    	}
	    	// this sanity check is basically just to get rid of the unused warning
	    	if (result != null) {
	    		logger.error("Received result object with dongle authentication success event with remote id " 
	    				+ remote + " while none expected. This event will be ignored. Object is " + result);
	    		return;
	    	}
			
	    	logger.info("Received dongle authentication success event at port " + serialPort + " with id " + remote);
	        
	    	String localTimes = "";
	    	DongleProtocolHandler h = null;
	    	if (!simulation) {
	    		// before forwarding the success event, send a success message to the remote and wait for its success message
        		h = (DongleProtocolHandler) sender;
    			// (also report the time it took on this side to the remote)
        		localTimes = h.getSendCommandTime() + " " + h.getDongleInterlockTime();
	    	}
	    	
	    	// report that success status to our super class and pass our times as parameters to the remote
	        /* Since we are in a DongleAuthenticationHandler right now, remote must be an Integer object, 
	           which we don't need to pass because remoteRelateId should hold the same value.
	    	   But we can (ab)use this object to pass the DongleProtocolHandler object to ourselves to the
	    	   protocolSucceededHook. */
	    	verificationSuccess(h, localTimes);
	    }

	    public void AuthenticationFailure(Object sender, Object remote, Exception e, String msg)
	    {
	    	if (! isVerifying()) {
	    		logger.error("Received dongle authentication failure event with remote id " + remote + 
	    			" from " + sender + " while not expecting one! This event will be ignored.");
	    		return;
	    	}
			
	        logger.info("Received dongle authentication failure event at port " + serialPort + " with id " + remote);
	        if (e != null)
	            logger.info("Exception: " + e /*+ "\n" +  e.getStackTrace()*/);
	        if (msg != null)
	            logger.info("Message: " + msg);
	        
	        String localTimes = "";
	        if (!simulation) {
	        	// and also send an authentication failed status to the remote
	        	DongleProtocolHandler h = (DongleProtocolHandler) sender;
	        	localTimes = h.getSendCommandTime() + " " + h.getDongleInterlockTime();
	        }
	        
	        verificationFailure(remote, localTimes, e, msg);
	    }

	    public void AuthenticationProgress(Object sender, Object remote, int cur, int max, String msg)
	    {
	    	if (! isVerifying()) {
	    		logger.error("Received dongle authentication progress event with remote id " + remote + 
	    			" from " + sender + " while not expecting one! This event will be ignored.");
	    		return;
	    	}
			
	        logger.debug("Received dongle authentication progress event at port " + serialPort + " with id " + remote + " " + cur + " out of " + max + ": " + msg);
	        raiseAuthenticationProgressEvent(remote, HostProtocolHandler.AuthenticationStages + cur, 
	        		HostProtocolHandler.AuthenticationStages + DongleProtocolHandler.AuthenticationStages + rounds,
	        		msg);
			if (relateEventHandler != null)
				relateEventHandler.progress(serialPort, 
					(remote instanceof String ? (String) remote : null),
					(remote instanceof Integer ? ((Integer) remote).intValue() : -1),
					HostProtocolHandler.AuthenticationStages + cur, 
	        			HostProtocolHandler.AuthenticationStages + DongleProtocolHandler.AuthenticationStages + rounds,
	        			msg);
	    }
	}


	
	
	/////////////////// Test code starting here, don't look below, it might make your eyes cross ////////////////////
	public static void setSimulationMode(boolean simulation) {
		RelateAuthenticationProtocol.simulation = simulation;
	}
	
	// helper function to better facilitate the experiments, just interrupt both dongles
	private static void resetBothDongles() {
		try {
			SerialConnector.getSerialConnector("/dev/ttyUSB0").switchDiagnosticMode(false);
		}
		catch (DongleException e) { 
			logger.error("Could not reset dongle");
		}
		try {
			Thread.sleep(2000);
		} catch (InterruptedException e) {}
		try {
			SerialConnector.getSerialConnector("/dev/ttyUSB1").switchDiagnosticMode(false);
		}
		catch (DongleException e) { 
			logger.error("Could not reset dongle");
		}
	}

    public static void main(String[] args) throws Exception
	{
		if (System.getProperty("os.name").startsWith("Windows CE")) {
			PropertyConfigurator.configure("log4j.properties");
		}

		class TempAuthenticationEventHandler implements AuthenticationProgressHandler {
			private int mode; // 0 = client, 1 = server, 2 = both
			
			private final static boolean useProgressBar = false;
			
			// test code for progress bar
			Object pb;
			Object d;
			Object s;
			
			public TempAuthenticationEventHandler(int mode) {
    			this.mode = mode;
    				
    			if (useProgressBar) {
    				d = new org.eclipse.swt.widgets.Display();
    				s = new org.eclipse.swt.widgets.Shell((org.eclipse.swt.widgets.Display) d);
    				((org.eclipse.swt.widgets.Shell) s).setLayout(new org.eclipse.swt.layout.GridLayout());
    				pb = new org.eclipse.swt.widgets.ProgressBar((org.eclipse.swt.widgets.Shell) s, org.eclipse.swt.SWT.HORIZONTAL | org.eclipse.swt.SWT.SMOOTH);
    				((org.eclipse.swt.widgets.ProgressBar) pb).setLayoutData(new org.eclipse.swt.layout.GridData(org.eclipse.swt.layout.GridData.FILL_HORIZONTAL));
    				((org.eclipse.swt.widgets.ProgressBar) pb).setMinimum(0);
    				((org.eclipse.swt.widgets.ProgressBar) pb).setMaximum(5);
    				((org.eclipse.swt.widgets.Shell) s).open();
    			}
    		}
    		
    		synchronized public void AuthenticationSuccess(Object sender, Object remote, Object result)
    		{
    			Object[] remoteParam = (Object[]) remote;
    			logger.info("Received relate authentication success event from " + sender + 
    					" with " + remoteParam[0] + "/" + remoteParam[1]);
    			if (result != null)
    				logger.error("Received result object while not expecting one: " + result);
    			System.out.println("SUCCESS");

    			// HACK HACK HACK HACK: interrupt the dongle to be sure to get it out of authentication mode
    			/*try {
    			 Thread.sleep(500); // should be long enough to send the last packet, if necessary
    			 } catch (InterruptedException e) {}
    			 outer.serialConn.switchDiagnosticMode(false);*/
   	        
    			if (mode == 0) {
    				if (! System.getProperty("os.name").startsWith("Windows CE")) 
    					Runtime.getRuntime().exit(0);
    			}
    			else if (mode == 2) {
    				// give it time to settle....
    				try {
    					Thread.sleep(3000);
    				} catch (InterruptedException e) {}
    				resetBothDongles();
    				Runtime.getRuntime().exit(0);
    			}
    		}
    	    
    		synchronized public void AuthenticationFailure(Object sender, Object remote, Exception e, String msg)
    		{
    			logger.info("Received relate authentication failure event from " + sender + " with " + remote);
    			Throwable exc = e;
    			while (exc != null) {
    				logger.info("Exception: " + exc);
    				exc = exc.getCause();
    			}
    			if (msg != null)
    				logger.info("Message: " + msg);

    			// HACK HACK HACK HACK: interrupt the dongle to be sure to get it out of authentication mode
    			/*try {
    			Thread.sleep(500); // should be long enough to send the last packet, if necessary
    			} catch (InterruptedException e1) {}
    			outer.serialConn.switchDiagnosticMode(false);*/
    	       
    			if (mode == 0) {
    				if (! System.getProperty("os.name").startsWith("Windows CE"))
    					Runtime.getRuntime().exit(1);
    			}
    			else if (mode == 2) {
    				resetBothDongles();
   					Runtime.getRuntime().exit(1);
   				}
   			}

   			public void AuthenticationProgress(Object sender, Object remote, int cur, int max, String msg)
   			{
   				logger.info("Received relate authentication progress event from " + sender + " with " + remote + " " + cur + " out of " + max + ": " + msg);
   				if (useProgressBar) {
   					final int m = max;
   					final int c = cur;
   					((org.eclipse.swt.widgets.Display) d).asyncExec(new Runnable() { public void run() { 
   						((org.eclipse.swt.widgets.ProgressBar) pb).setMaximum(m); ((org.eclipse.swt.widgets.ProgressBar) pb).setSelection(c); }});
   				}
   			}
   		}
    
   		boolean useJSSEServer = true;
   		boolean useJSSEClient = true;
   		if (System.getProperty("os.name").startsWith("Windows CE")) {
   			useJSSEServer = useJSSEClient = false;
   		}
    	
        if (args.length > 1 && args[0].equals("server")) {
        	logger.info("Starting server mode");
        	String serialPort = args[1];
        		
            // no longer need this
            //int referenceMeasurement1 = helper_getReferenceMeasurement(serialPort, (byte) Integer.parseInt(args[2]));

            // set the serial port to prevent EventDispatcher from asking in its init
            EventDispatcher.getDispatcher(new String[] {serialPort});
            // this will start the SerialConnector thread and start listening for incoming measurements
            MeasurementManager man = new MeasurementManager(serialPort);

            // this initializes the object with the passed arguments, but doesn't do much else 
            RelateAuthenticationProtocol r = new RelateAuthenticationProtocol(serialPort, man, useJSSEServer, false, null);
            // register the listeners
            TempAuthenticationEventHandler ht = new TempAuthenticationEventHandler(1);
            r.addAuthenticationProgressHandler(ht);
        	// and start....
            r.startServer();
            //new BufferedReader(new InputStreamReader(System.in)).readLine();

            while (true) Thread.sleep(1000);

            //h1.stopListening();
        } 
        else if (args.length > 4 && args[0].equals("client")) {
        	System.out.println("starting client mode: port=" + args[1] + ", server=" + args[2] + ", remoteid=" + args[3] + ", rounds=" + args[4]);
        	String serialPort = args[1];
        	logger.info("Starting client mode");
            EventDispatcher.getDispatcher(new String[] {serialPort});
            MeasurementManager man = new MeasurementManager(serialPort);
        	RelateAuthenticationProtocol r = new RelateAuthenticationProtocol(serialPort, man, useJSSEClient, false, null);
        	TempAuthenticationEventHandler t = new TempAuthenticationEventHandler(0);
        	r.addAuthenticationProgressHandler(t);
        	r.startAuthentication(args[2], (byte) Integer.parseInt(args[3]), Integer.parseInt(args[4]));
            // This is the last safety belt: a timer to kill the client if the dongle hangs for some reason. This is
            // not so simple for the server.
            new Thread(new Runnable() {
            	public void run() {
            		System.out.println("******** Starting timer");
            		// two minutes should really be enough
            		try {
            			Thread.sleep(120 * 1000);
            		} catch (InterruptedException e) {}
            		System.out.println("******** Timed out");
        			statisticsLogger.error("- Timer killed client");
   	        		resetBothDongles();
   	        		if (! System.getProperty("os.name").startsWith("Windows CE"))
   	        			System.exit(100);
            	}
            }).start();

            //new BufferedReader(new InputStreamReader(System.in)).readLine();

            if (TempAuthenticationEventHandler.useProgressBar) {
            	while (! ((org.eclipse.swt.widgets.Shell) t.s).isDisposed()) {
            		if (((org.eclipse.swt.widgets.Display) t.d).readAndDispatch())
            			((org.eclipse.swt.widgets.Display) t.d).sleep();
            	}
            }
            else
                while (true) Thread.sleep(1000);
        }
        else if (args.length == 2 && args[0].equals("both")) {
        	logger.info("Starting mutual authentication mode with two dongles");
        	int localId1 = -1, localId2 = -1;
        	String serialPort1 = "/dev/ttyUSB0", serialPort2 = "/dev/ttyUSB1";

        	// first need to get my local ids
        	try {
        		SerialConnector s1 = SerialConnector.getSerialConnector(serialPort1);
        		localId1 = s1.getLocalRelateId();
        		Thread.sleep(3000);
        		SerialConnector s2 = SerialConnector.getSerialConnector(serialPort2);
        		localId2 = s2.getLocalRelateId();
        	}
        	catch (DongleException e) {
        		logger.error("-------- failed to connect to dongle, didn't get my ID.");
        		System.out.println(e);
        		//e.printStackTrace();
        		if (! System.getProperty("os.name").startsWith("Windows CE"))
        			System.exit(1);
        	}

        	logger.info("Connected to my two dongles: ID " + localId1 + " on " + serialPort1 + ", and ID " + localId2 + " on " + serialPort2);

            EventDispatcher.getDispatcher(new String[] {serialPort1, serialPort2});
            MeasurementManager man1 = new MeasurementManager(serialPort1);
            MeasurementManager man2 = new MeasurementManager(serialPort2);
        		
        	// server side
        	TempAuthenticationEventHandler ht = new TempAuthenticationEventHandler(2);
            RelateAuthenticationProtocol r_serv = new RelateAuthenticationProtocol(serialPort1, man1, useJSSEServer, false, null);
            r_serv.addAuthenticationProgressHandler(ht);
            r_serv.startServer();

            // client side
            RelateAuthenticationProtocol r_client = new RelateAuthenticationProtocol(serialPort2, man2, useJSSEClient, false, null);
        	r_client.addAuthenticationProgressHandler(ht);
        	r_client.startAuthentication("localhost", (byte) localId1, Integer.parseInt(args[1]));
        	
        	// safety belt
            new Thread(new Runnable() {
            	public void run() {
            		System.out.println("******** Starting timer");
            		// two minutes should really be enough
            		try {
            			Thread.sleep(120 * 1000);
            		} catch (InterruptedException e) {}
            		System.out.println("******** Timed out");
            		statisticsLogger.error("- Timer killed client");
            		if (! System.getProperty("os.name").startsWith("Windows CE"))
            			System.exit(100);
            		}
            	}).start();

            // and wait
            while (true) Thread.sleep(1000);
        }
        
        // problem with the javax.comm API - doesn't release its native thread
        if (! System.getProperty("os.name").startsWith("Windows CE"))
       		System.exit(0);
	}
}
