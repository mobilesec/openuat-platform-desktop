/* Copyright Rene Mayrhofer
 * File created 2005-09
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */
package org.openuat.authentication.relate;

import org.openuat.authentication.AuthenticationEventSender;
import org.openuat.authentication.AuthenticationProgressHandler;
import org.openuat.authentication.DHWithVerification;
import org.openuat.authentication.HostProtocolHandler;
import org.openuat.authentication.KeyManager;
import org.openuat.authentication.accelerometer.ShakeWellBeforeUseProtocol1;
import org.openuat.util.RemoteConnection;
import org.openuat.util.RemoteTCPConnection;
import org.openuat.util.TCPPortServer;

import java.io.*;
import java.net.Socket;
import java.net.UnknownHostException;
//import java.util.Arrays;
import java.util.Iterator;

import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;

import uk.ac.lancs.relate.core.Configuration;
import uk.ac.lancs.relate.core.MeasurementQueue;
import uk.ac.lancs.relate.core.SerialConnector;
import uk.ac.lancs.relate.core.DeviceException;
import uk.ac.lancs.relate.core.Measurement;
import uk.ac.lancs.relate.core.MeasurementManager;
import uk.ac.lancs.relate.core.EventDispatcher;
import uk.ac.lancs.relate.events.MeasurementEvent;
import uk.ac.lancs.relate.auth.ProgressEventHandler;
//import uk.ac.lancs.relate.events.RelateEvent;
//import uk.ac.lancs.relate.core.MessageQueue;

/** This is the main class of the relate authentication software: it ties together
 * the host and dongle protocol handlers. Since both handlers work asynchronously
 * in their own threads, this class must also handle the synchronisation between 
 * all events coming in from them.
 * 
 * It can generate two types of events of its own: as a subclass of AuthenticationEventSender, it
 * sende AuthenticationEvents to all registered AuthenticationProgressHandler. Additionally, when
 * a ProgressEventHandler object is given to the constructor, it will generate the more specific
 * relate events.
 * 
 * The authentication success event generated by this protocol will return an
 * object array consisting of a String object and an Integer object for the
 * remote parameter and either a byte or an object array as the result parameter.
 * For the remote parameter, the first object (String) represents the remote canonical host name
 * address, while the second object (Integer) represents the remote Relate id.
 * The result parameter will contain only the session key as a byte array when 
 * keepConnected has been set to false in the constructor, but will contain
 * an Object array with the session key (again as a byte array) as its first entry
 * and the RemoteConnection object as its second entry when keepConnected has been 
 * set to true.
 * 
 * The authentication failure and progress events to not go to these lengths and will
 * return either a String object or an Integer object as the remote parameter,
 * depending on the current stage of the Relate protocol when the event occurs.
 * 
 * @author Rene Mayrhofer
 * @version 1.0
 */
public class RelateAuthenticationProtocol extends DHWithVerification {
	/** Our log4j logger. */
	private static Logger logger = Logger.getLogger(RelateAuthenticationProtocol.class);
	/** This is a special log4j logger used for logging only statistics. It is separate from the main logger
	 * so that it's possible to turn statistics on an off independently.
	 */
	private static Logger statisticsLogger = Logger.getLogger("statistics.relateauthentication");

	public static final int TcpPort = 54321;

	/** Allow the (incoming) key agreement to take at maximum this amout of ms. */
	public static final int KeyAgreementProtocolTimeout = 10000;

	// TODO: remove me now that it should be simple to implement a dummy protocol that works like this
	// class with simulation = true
	/** If set to true, then all the code will run without communicating with a dongle. This is helpful
	 * for simulation the authentication without the actual dongle. It can be used for debugging and
	 * testing.
	 */
	private static boolean simulation = false;
	
	/** The serial port that is used by this authentication protocol instance to connect to its dongle. */
	private String serialPort;
	
	/** The measurement manager object which listens for measurments coming from the used serial port.
	 * It will be used to fetch the reference measurement.
	 * @see #referenceMeasurement
	 */
	private MeasurementManager manager;
	
	/** This is just a helper to hold the remoteRelateId that is passed to startAuthentication
	 * until it is needed when starting the DongleProtocolHandler (after the HostProtocolHandler
	 * has finished successfully). When set to -1, this indicates "server" mode where the remote
	 * relate id is taken from the optionalParameter of the HostAuthenticationSuccess event. When
	 * not -1, this indicates "client" mode and this id will be taken.
	 * @see #startAuthentication
	 * @see #startVerification(byte[], String, String, Socket)
	 */
	private int remoteRelateId = -1;

	/** The number of rounds used for the spatial authentication protocol. This is used to remember
	 * th enumber of rounds that is agreed to when phase 1 finished, so that it can be access in
	 * phase 2. It will only be valid during a running verification phase and will be set to -1
	 * at any other time.
	 */
	private int rounds = -1;
	
	/** AuthenticationProgressEvents will be forwarded to this more Relate-specific handler, when
	 * set != null. It is a second possibility for this class to fire events, in addition to the
	 * methods offered by AuthenticationEventSender.
	 */
	private ProgressEventHandler relateEventHandler = null;
	
	/** The reference measurement to the remoteRelateId device taken when the
	 * user selected this device for authentication, or the last one taken 
	 * before the authentication request came in on the server end.
	 * <br>
	 * This measurement is taken from the MeasurementManager (which records past
	 * measurements) and stored when startAuthentication is called (i.e. an
	 * "outgoing" authentication is being initialized) or when an incoming
	 * host authentication has succeeded (i.e. an "incoming" authentication is
	 * being initialized).
	 * 
	 * @see #startAuthentication for the "outgoing" authentication
	 * @see #startVerification(byte[], String, String, Socket) for the "incoming" authentication
	 * @see #fetchReferenceMeasurement is the helper method used for both incoming and outgoing
	 */
	private int referenceMeasurement = -1;
	
	/** This holds the reference to the remote we are currently authentication with.
	 * It is set in startVerificationAsync and used by the DongleAuthenticationEventHandler 
	 * when calling verificationSuccess or verificationFailure.
	 * @see #startVerificationAsync
	 * @see DongleAuthenticationEventHandler#AuthenticationSuccess
	 * @see DongleAuthenticationEventHandler#AuthenticationFailure  
	 */
	private RemoteConnection remoteHost = null;
	
	/** Initialized the authentication object with the contact data of the remote device to authenticate with.
	 * This constructor also gets a reference measurement to the remote relate id by itself. This needs better
	 * integration with the Relate framework, the reference measurement should come from "the outside".
	 * 
	 * @param serialPort The serial port to which the dongle is connected
	 * @param manager The measurement manager to use. This manager should be registered at the dongle 
	 *                that is connected to serialPort and should keep a history of the last measurement
	 *                received locally from this dongle. It will be used by RelateAuthenticationProtocol
	 *                to fetch the reference measurement before starting the spatial authentication 
	 *                protocol.
	 * @param useJSSE If set to true, the JSSE API with the default JCE provider of the JVM will be used
	 *                for cryptographic operations. If set to false, an internal copy of the Bouncycastle
	 *                Lightweight API classes will be used.
	 * @param keepSocketConnected
	 *            If set to true, the opened client socket soc is passed to the
	 *            authentication success event (in the results parameter) for 
	 *            further re-use of the connection (e.g. passing additional 
	 *            information about further protocol steps). If set to false, the
	 *            socket will be closed when this protocol is done with it. The socket
	 *            will always be closed on authentication failures.
	 *            If in doubt, set to false;
	 * @param relateEventHandler If set to an object != null, it will get notified of all events.
	 */
	public RelateAuthenticationProtocol(String serialPort, MeasurementManager manager, boolean useJSSE,
				boolean keepSocketConnected, ProgressEventHandler relateEventHandler) {
		super(new TCPPortServer(ShakeWellBeforeUseProtocol1.TcpPort, KeyAgreementProtocolTimeout, false, true),
				keepSocketConnected, false, serialPort, useJSSE);
		
		if (!simulation) {
			// when simulating, we won't have these
			this.serialPort = serialPort;
			this.manager = manager;
		}
		this.relateEventHandler = relateEventHandler;
	}
	
	/** This is only a helper method to fetch the reference measurement to a remote host from the
	 * MeasurementManager. It will block until such a measurement could be received.
	 * 
	 * @param remoteIdToMeasure The remote relate id to get the reference measurement to.
	 * @return The reference measurement.
	 * 
	 * @see #startAuthentication for the "outgoing" authentication
	 * @see #startVerification(byte[], String, String, Socket) for the "incoming" authentication
	 */
	private int fetchReferenceMeasurement(int remoteIdToMeasure) {
		int ref = -1;
		while (ref == -1) {
			logger.debug("Fetching reference mesurements from dongle at port " + serialPort + " to remote id " + remoteIdToMeasure);
			/* this gives us all the measurements that the local dongle took (i.e. where the 
			 * getDongleId() of MeasurementEvent was equal to the localRelateId) to the remote 
			 * dongle (i.e. where Measurement.getRelatumId was equal to remoteRelateId) */
			MeasurementQueue measurements = manager.getLocalMeasurementsTo(remoteIdToMeasure);
			// simply find the first (i.e. newest) valid measurement
			Iterator iter = measurements.iterator();
			while (ref == -1 && iter.hasNext()) {
				Measurement m = (Measurement) iter.next();
				logger.debug("Examining measurement from dongle at port " + serialPort + ": " + m);
				if (m.getTransducers() > 0 && m.getDistance() < 4094) {
					ref = m.getDistance();
					logger.info("Taking reference measurement from dongle at port " + serialPort + " to remote id " + remoteIdToMeasure + ": " + ref);
				}
			}
			if (ref == -1) { 
				// no measurements in the list yet, wait for it to happen
				logger.info("No measurement from dongle at port " + serialPort + " to remote id " + remoteIdToMeasure + " yet. Waiting.");
				try {
					Thread.sleep(500);
				} catch (InterruptedException e) {
					// just ignore, doesn't matter too much if it's shorter
				}
			}
		}
		return ref;
	}
	
	/** Starts the spatial authentication protocol in the background. Listeners should subscribe to
	 * authentication events to get notified about the progress of authentication.
	 * @param remoteHost The hostname/IP address of the remote device to send an authentication request to.
	 * @param remoteRelateId The relate id of the remote device. This is set by the client only
	 *                       to enable stricter error checks. T
	 * @param rounds The number of rounds that should be used for the dongle authentication. This
	 * directly influences the achieved security level, as described in DongleProtocolHandler#handleDongleCommunication.
	 * 
	 * @return true if the authentication could be started, false otherwise.
	 * 
	 * @see AuthenticationEventSender#addAuthenticationProgressHandler
	 * @see DongleProtocolHandler#handleDongleCommunication
	 */
	public boolean startAuthentication(String remoteHost, 
			// TODO: activate me again when J2ME polish can deal with Java5 sources!
			//@SuppressWarnings("hiding") // this sets the member variable
			int remoteRelateId, 
			// TODO: activate me again when J2ME polish can deal with Java5 sources!
			//@SuppressWarnings("hiding") // this indirectly (via the optional parameter passing) sets the member variable later on
			int rounds) 
			throws UnknownHostException, IOException/*, ConfigurationErrorException, InternalApplicationException*/ {
		if (rounds < 2) {
			logger.error("Invalid number of rounds (" + rounds + "), need at least 2");
			return false;
		}
		
		/* remember the remote relate id for later to pass it to the DongleAuthenticationHandler when
		 * the HostProtocolHandler has finished successfully.
		 */	
		this.remoteRelateId = remoteRelateId;
		
		int localRelateId = -1;
		if (!simulation) {
			// this code block only gets our local relate id so that it can be transmitted to the other host
			SerialConnector serialConn;
			try {
				// Connect here to the dongle so that we don't block it when not necessary. This needs better integration with the Relate framework.
				// TODO: maybe stop hard-coding the device type for the "old" USB dongle
				serialConn = SerialConnector.getSerialConnector(serialPort, 1);
				logger.info("-------- connected successfully to dongle at port " + serialPort + ", including first handshake. My ID is " + serialConn.getLocalRelateId());
			}
			catch (DeviceException e) {
				logger.error("-------- failed to connect to dongle at port " + serialPort + ", didn't get my ID.");
				// throw new ConfigurationErrorException("Can't connect to dongle.", e);
				return false;
			}
		
			localRelateId = serialConn.getLocalRelateId();
			if (localRelateId == -1)
				//throw new InternalApplicationException("Dongle reports id -1, which is an error case.");
				return false;

			/* And remember the last reference measurement taken to the remote relate id for
			 * future use (i.e. computing the delays).
			 */
			referenceMeasurement = fetchReferenceMeasurement(remoteRelateId);
		}
		else
			logger.warn("Skipping to get local relate id and reference measurement due to simulation mode");
		
		// create the optional parameter object to pass, consisting of the relate id and the number of rounds
		String param = Integer.toString(localRelateId) + " " + Integer.toString(rounds);
		if (!startAuthentication(new RemoteTCPConnection(new Socket(remoteHost, TcpPort)), KeyAgreementProtocolTimeout, param)) {
			logger.error("Could not start authentication with " + remoteHost + ", relate id " + remoteRelateId);
			return false;
		}
		else
			return true;
	}
	
	/** Called by the base class when the object is reset to idle state. */
	// TODO: activate me again when J2ME polish can deal with Java5 sources!
	//@Override
	protected void resetHook(RemoteConnection remote) {
		// this needs to be reset so that the handler will be in "server" state
		remoteRelateId = -1;
		referenceMeasurement = -1;
		remoteHost = null;
		// also reset number of rounds
		rounds = -1;
	}
	
	/** Called by the base class when the whole authentication protocol succeeded. 
	 * <b>Note:</b> The optionalRemoteId object is (ab)used not to pass an Integer 
	 * object with the remote relate ID, but the full DongleProtocolHandler, so 
	 * that the protocol execution times can be queried. 
	 */
	// TODO: activate me again when J2ME polish can deal with Java5 sources!
	//@Override
	protected void protocolSucceededHook(RemoteConnection remote, Object optionalVerificationId, 
			String optionalParameterFromRemote, byte[] sharedSessionKey) {
		/* the optionalRemoteReference is set to the DongleProtocolHandler object
		 * in AuthenticationSuccess and authenticationFailure handlers */
		DongleProtocolHandler localSide = (DongleProtocolHandler) keyManager.getOptionalRemoteReference(remote);
		logger.debug("protocolSucceededHook called at port " + serialPort + " with remote " + 
				remote + "/" + optionalVerificationId + ", param " + optionalParameterFromRemote + ", session key " + 
				SerialConnector.byteArrayToHexString(sharedSessionKey));
		
		// in addition to the "standard" event sent by the super class, send the specialized Relate event too
		if (relateEventHandler != null)
			relateEventHandler.success(serialPort, remote.getRemoteName(), 
					localSide.getRemoteRelateId(), (byte) rounds, sharedSessionKey, ((RemoteTCPConnection) remote).getSocketReference());

		// and log to the statistics logger!
		if (!simulation) {
    		// first extract the values from the optional remote status string
    		String values[] = optionalParameterFromRemote.split(" ", 2);
    		// first local, than remote times
    		statisticsLogger.info("+ " + rounds + " " + referenceMeasurement + " " +
    				localSide.getSendCommandTime() + " " + localSide.getDongleInterlockTime() +
    				" " + values[0] + " " + values[1] + " Dongle authentication succeeded");
		}
	}
	
	/** Called by the base class when the whole authentication protocol failed. 
	 * <b>Note:</b> The optionalRemoteId object may be (ab)used not to pass an Integer 
	 * object with the remote relate ID, but the full DongleProtocolHandler, so 
	 * that the protocol execution times can be queried.  But since this method can also
	 * be called when HostAuthenticationProtocol fails, we don't know if optionalRemoteId
	 * is going to be set - can't use it here at all.
	 */
	// TODO: activate me again when J2ME polish can deal with Java5 sources!
	//@Override
	protected void protocolFailedHook(RemoteConnection remote, Object optionalVerificationId,
			Exception e, String message) {
		logger.error("Authentication protocol failed at port " + serialPort + 
				" with " + remote + "/" + optionalVerificationId + "%" + remoteRelateId + ": " + e + " / " + message);
		if (relateEventHandler != null)
			relateEventHandler.failure(serialPort, remote.getRemoteName(),
					keyManager.getOptionalRemoteReference(remote) instanceof DongleProtocolHandler ? 
							((DongleProtocolHandler) keyManager.getOptionalRemoteReference(remote)).getRemoteRelateId() : -1, 
					e, message);

		// also log that failure to the statistics logger
		if (!simulation)
			statisticsLogger.error("- " + rounds + " " + referenceMeasurement + 
					" Authentication failed: '" + e + "' / '" + message);
	}

	/** Called by the base class when the whole authentication protocol shows progress. 
	 * <b>Note:</b> The optionalRemoteId object may be (ab)used not to pass an Integer 
	 * object with the remote relate ID, but the full DongleProtocolHandler, so 
	 * that the protocol execution times can be queried.  But since this method can also
	 * be called when HostAuthenticationProtocol fails, we don't know if optionalRemoteId
	 * is going to be set - can't use it here at all.
	 */
	// TODO: activate me again when J2ME polish can deal with Java5 sources!
	//@Override
	protected void protocolProgressHook(RemoteConnection remote, int cur, int max, String message) {
		logger.debug("protocolProgressHook called at port " + serialPort + " with " + 
				remote + ": " + cur + "/" + max + ": " + message);
		if (relateEventHandler != null) {
			Object optionalRemoteReference = keyManager.getOptionalRemoteReference(remote);
			relateEventHandler.progress(serialPort, remote.getRemoteName(),
					optionalRemoteReference instanceof DongleProtocolHandler ? 
							((DongleProtocolHandler) optionalRemoteReference).getRemoteRelateId() : -1, 
				cur, max, message);
		}
	}
	protected void protocolStartedHook(RemoteConnection remote) {
		logger.debug("protocolStartedHook called at port " + serialPort + " with " + 
				remote);
	}
	
	/** Called by the base class when shared keys have been established and should be verified now.
	 * In this implementation, verification is done by starting a DongleAuthenticationProtocol. 
	 */
	// TODO: activate me again when J2ME polish can deal with Java5 sources!
	//@Override
	protected void startVerificationAsync(byte[] sharedAuthenticationKey, 
			String param, RemoteConnection toRemote) {
		// first do some sanity checks
		// TODO: these checks are bogus now - what did they do in the past?
		if (referenceMeasurement != -1)
			logger.error("Internal inconsistency! Object is idle in server mode, but referenceMeasurement is set");
		if (remoteRelateId != -1)
			logger.error("Internal inconsistency! Object is idle in server mode, but remoteRelateId is set");
		
		logger.info("Starting key verification at port " + serialPort + " after successful host authentication with " +
				toRemote.getRemoteName() + ", socketToRemote is " + toRemote);
		
		// remember the remote!
		remoteHost = toRemote;

        /* extract the optional parameters (in the case of the RelateAuthenticationProtocol: the remote
        relate id to authenticate with and the number of rounds - we assume them to be set) as well as the 
        socket (which is assumed to be still connected to the remote) */
		logger.debug("Splitting received param string '" + param + "'");
		String param1 = param.substring(0, param.indexOf(' '));
		String param2 = param.substring(param.indexOf(' ')+1, param.length());
		// distinguish between client and server mode here
		int otherRelateId;
		if (remoteRelateId != -1) {
			// "client" mode - this is the id that was passed to startAuthentication
     		otherRelateId = remoteRelateId;
     		logger.debug("Client mode at port " + serialPort + ": taking remote relate id that was passed earlier: " + otherRelateId);
		}
		else {
     		// "server" mode - take the id that was passed by the client
     		otherRelateId = Integer.parseInt(param1);
     		logger.debug("Server mode at port " + serialPort + ": taking remote relate id from authentication request message: " + otherRelateId);
 			/* And remember the last reference measurement taken to the remote relate id for
 			 * future use (i.e. computing the delays). For client mode, it has been set even
 			 * before starting the host authentication phase.
 			 */
     		if (!simulation)
     			referenceMeasurement = fetchReferenceMeasurement(otherRelateId);
     		else
     			logger.warn("Skipping to get reference measurement due to simulation mode");
		}
		rounds = Integer.parseInt(param2);
		logger.debug("Parameters for dongle authentication are now remoteId=" + 
				otherRelateId + ", rounds=" + rounds);

        if (!simulation) {
        	// and use the agreed authentication key to start the dongle authentication
        	logger.debug("Starting dongle authentication at dongle " + serialPort + " with remote relate id " + otherRelateId + " and " + rounds + " rounds.");
        	DongleProtocolHandler dh = new DongleProtocolHandler(serialPort, otherRelateId, useJSSE);
        	dh.addAuthenticationProgressHandler(new DongleAuthenticationEventHandler());
        	/* IMPORTANT NOTE: this uses the authentication key, and not the shared secret on purpose! The
        	 * authentication key is used for no other purpose, so even a problem with the protocol should
        	 * not reveal the shared secret key.
        	 */
        	dh.startAuthentication(sharedAuthenticationKey, rounds, referenceMeasurement);
        }
        else {
        	logger.warn("Skipping to start dongle authentication with " + rounds + " rounds due to simulation mode, assuming immediate authentication success");
        	new DongleAuthenticationEventHandler().AuthenticationSuccess(null, new Integer(-1), null);
        }
	}
	
	/** A helper class for handling the events from DongleProtocolHandler. These give us the final
	 * decisions and are forwarded. 
	 */
	private class DongleAuthenticationEventHandler implements AuthenticationProgressHandler {
	    public void AuthenticationSuccess(Object sender, Object remote, Object result) {
	    	if (keyManager.getState(remoteHost) != KeyManager.STATE_VERIFICATION) {
	    		logger.error("Received dongle authentication success event with remote id " + remote + 
	    				" from " + sender + " while not expecting one! This event will be ignored.");
	    		return;
	    	}
	    	// this sanity check is basically just to get rid of the unused warning
	    	if (result != null) {
	    		logger.error("Received result object with dongle authentication success event with remote id " 
	    				+ remote + " while none expected. This event will be ignored. Object is " + result);
	    		return;
	    	}
			
	    	logger.info("Received dongle authentication success event at port " + serialPort + " with id " + remote);
	        
	    	String localTimes = "";
	    	DongleProtocolHandler h = null;
	    	if (!simulation) {
	    		// we know that the sender must have been a DongleProtocolHandler, so access this...
        		h = (DongleProtocolHandler) sender;
    			// ... to report the time it took on this side to the remote
        		localTimes = h.getSendCommandTime() + " " + h.getDongleInterlockTime();
        		/* and remember this reference for later usage (protocolSucceededHook
        		 * possibly called from verificationSuccess, will use it again) */
        		keyManager.setOptionalRemoteReference(remoteHost, h);
	    	}
	    	
	    	// report that success status to our super class and pass our times as parameters to the remote
	    	verificationSuccess(remoteHost, remote, localTimes);
	    }

	    public void AuthenticationFailure(Object sender, Object remote, Exception e, String msg) {
	    	if (keyManager.getState(remoteHost) != KeyManager.STATE_VERIFICATION) {
	    		logger.error("Received dongle authentication failure event with remote id " + remote + 
	    			" from " + sender + " while not expecting one! This event will be ignored.");
	    		return;
	    	}
			
	        logger.info("Received dongle authentication failure event at port " + serialPort + " with id " + remote);
	        if (e != null)
	            logger.info("Exception: " + e /*+ "\n" +  e.getStackTrace()*/);
	        if (msg != null)
	            logger.info("Message: " + msg);
	        
	        String localTimes = "";
	        if (!simulation) {
	        	// and also send an authentication failed status to the remote
	        	DongleProtocolHandler h = (DongleProtocolHandler) sender;
	        	localTimes = h.getSendCommandTime() + " " + h.getDongleInterlockTime();
	        	// and again remember it so that protocolFailedHook can access it
        		keyManager.setOptionalRemoteReference(remoteHost, h);
	        }
	        
	        verificationFailure(remoteHost, remote, localTimes, e, msg);
	    }

	    public void AuthenticationProgress(Object sender, Object remote, int cur, int max, String msg) {
	    	if (keyManager.getState(remoteHost) != KeyManager.STATE_VERIFICATION) {
	    		logger.error("Received dongle authentication progress event with remote id " + remote + 
	    			" from " + sender + " while not expecting one! This event will be ignored.");
	    		return;
	    	}
			
	        logger.debug("Received dongle authentication progress event at port " + serialPort + " with id " + remote + " " + cur + " out of " + max + ": " + msg);
	        raiseAuthenticationProgressEvent(remote, HostProtocolHandler.AuthenticationStages + cur, 
	        		HostProtocolHandler.AuthenticationStages + DongleProtocolHandler.AuthenticationStages + rounds,
	        		msg);
			if (relateEventHandler != null)
				relateEventHandler.progress(serialPort, 
					(remote instanceof String ? (String) remote : null),
					(remote instanceof Integer ? ((Integer) remote).intValue() : -1),
					HostProtocolHandler.AuthenticationStages + cur, 
	        			HostProtocolHandler.AuthenticationStages + DongleProtocolHandler.AuthenticationStages + rounds,
	        			msg);
	    }

	    public boolean AuthenticationStarted(Object sender, Object remote) {
	    	if (keyManager.getState(remoteHost) != KeyManager.STATE_VERIFICATION) {
	    		logger.error("Received dongle authentication started event with remote id " + remote + 
	    			" from " + sender + " while not expecting one! This event will be ignored.");
	    		return false;
	    	}
			
	        logger.debug("Received dongle authentication progress event at port " + serialPort + " with id " + remote);
	        return raiseAuthenticationStartedEvent(remote);
	    }
	}


	
	
	/////////////////// Test code starting here, don't look below, it might make your eyes cross ////////////////////
	public static void setSimulationMode(boolean simulation) {
		RelateAuthenticationProtocol.simulation = simulation;
	}
	
	// helper function to better facilitate the experiments, just interrupt both dongles
	private static void resetBothDongles(int deviceType) {
		try {
			SerialConnector.getSerialConnector("/dev/ttyUSB0", 1).switchDiagnosticMode(false);
		}
		catch (DeviceException e) { 
			logger.error("Could not reset dongle");
		}
		try {
			Thread.sleep(deviceType == 1 ? 2000 : 500);
		} catch (InterruptedException e) {
			// just ignore, it doesn't matter too much if it's shorter
		}
		try {
			SerialConnector.getSerialConnector("/dev/ttyUSB1", 1).switchDiagnosticMode(false);
		}
		catch (DeviceException e) { 
			logger.error("Could not reset dongle");
		}
	}

    public static void main(String[] args) throws Exception
	{
		if (System.getProperty("os.name").startsWith("Windows CE")) {
			PropertyConfigurator.configure("log4j.properties");
		}

		class TempAuthenticationEventHandler implements AuthenticationProgressHandler {
			private int mode; // 0 = client, 1 = server, 2 = both
			private int deviceType;
			
			private final static boolean useProgressBar = false;
			
			// test code for progress bar
			Object pb;
			Object d;
			Object s;
			
			public TempAuthenticationEventHandler(int mode, int deviceType) {
    			this.mode = mode;
    			this.deviceType = deviceType;
    				
    			if (useProgressBar) {
    				d = new org.eclipse.swt.widgets.Display();
    				s = new org.eclipse.swt.widgets.Shell((org.eclipse.swt.widgets.Display) d);
    				((org.eclipse.swt.widgets.Shell) s).setLayout(new org.eclipse.swt.layout.GridLayout());
    				pb = new org.eclipse.swt.widgets.ProgressBar((org.eclipse.swt.widgets.Shell) s, org.eclipse.swt.SWT.HORIZONTAL | org.eclipse.swt.SWT.SMOOTH);
    				((org.eclipse.swt.widgets.ProgressBar) pb).setLayoutData(new org.eclipse.swt.layout.GridData(org.eclipse.swt.layout.GridData.FILL_HORIZONTAL));
    				((org.eclipse.swt.widgets.ProgressBar) pb).setMinimum(0);
    				((org.eclipse.swt.widgets.ProgressBar) pb).setMaximum(5);
    				((org.eclipse.swt.widgets.Shell) s).open();
    			}
    		}
    		
    		synchronized public void AuthenticationSuccess(Object sender, Object remote, Object result)
    		{
    			Object[] remoteParam = (Object[]) remote;
    			logger.info("Received relate authentication success event from " + sender + 
    					" with " + remoteParam[0] + "/" + remoteParam[1]);
    			if (result == null)
    				logger.error("Did not receive a result object, don't know the session key");
    			else
    				logger.info("Session key is now " + SerialConnector.byteArrayToHexString((byte[]) result));
    			System.out.println("SUCCESS");

    			// HACK HACK HACK HACK: interrupt the dongle to be sure to get it out of authentication mode
    			/*try {
    			 Thread.sleep(500); // should be long enough to send the last packet, if necessary
    			 } catch (InterruptedException e) {}
    			 outer.serialConn.switchDiagnosticMode(false);*/
   	        
    			if (mode == 0) {
    				if (! System.getProperty("os.name").startsWith("Windows CE")) 
    					Runtime.getRuntime().exit(0);
    			}
    			else if (mode == 2) {
    				// give it time to settle....
    				try {
    					Thread.sleep(deviceType == 1 ? 3000 : 500);
    				} catch (InterruptedException e) {
    					// just ignore, it doesn't matter too much if it's shorter
    				}
    				resetBothDongles(deviceType);
    				Runtime.getRuntime().exit(0);
    			}
    		}
    	    
    		synchronized public void AuthenticationFailure(Object sender, Object remote, Exception e, String msg)
    		{
    			logger.info("Received relate authentication failure event from " + sender + " with " + remote);
    			Throwable exc = e;
    			while (exc != null) {
    				logger.info("Exception: " + exc);
    				exc = exc.getCause();
    			}
    			if (msg != null)
    				logger.info("Message: " + msg);

    			// HACK HACK HACK HACK: interrupt the dongle to be sure to get it out of authentication mode
    			/*try {
    			Thread.sleep(500); // should be long enough to send the last packet, if necessary
    			} catch (InterruptedException e1) {}
    			outer.serialConn.switchDiagnosticMode(false);*/
    	       
    			if (mode == 0) {
    				if (! System.getProperty("os.name").startsWith("Windows CE"))
    					Runtime.getRuntime().exit(1);
    			}
    			else if (mode == 2) {
    				resetBothDongles(deviceType);
   					Runtime.getRuntime().exit(1);
   				}
   			}

   			public void AuthenticationProgress(Object sender, Object remote, int cur, int max, String msg)
   			{
   				logger.info("Received relate authentication progress event from " + sender + " with " + remote + " " + cur + " out of " + max + ": " + msg);
   				if (useProgressBar) {
   					final int m = max;
   					final int c = cur;
   					((org.eclipse.swt.widgets.Display) d).asyncExec(new Runnable() { public void run() { 
   						((org.eclipse.swt.widgets.ProgressBar) pb).setMaximum(m); ((org.eclipse.swt.widgets.ProgressBar) pb).setSelection(c); }});
   				}
   			}

   			public boolean AuthenticationStarted(Object sender, Object remote)
   			{
   				logger.info("Received relate authentication started event from " + sender + " with " + remote);
   				return true;
   			}
		}
    
   		boolean useJSSEServer = true;
   		boolean useJSSEClient = true;
   		if (System.getProperty("os.name").startsWith("Windows CE")) {
   			useJSSEServer = useJSSEClient = false;
   		}
    	
        if (args.length > 2 && args[0].equals("server")) {
        	logger.info("Starting server mode");
        	String serialPort = args[1];
        	int deviceType = Integer.parseInt(args[2]);
        		
            // no longer need this
            //int referenceMeasurement1 = helper_getReferenceMeasurement(serialPort, Integer.parseInt(args[2]));
        	
        	Configuration conf = new Configuration(serialPort, deviceType);
        	SerialConnector connector = SerialConnector.getSerialConnector(conf.getDevicePortName(), conf.getDeviceType());
        	connector.registerEventQueue(EventDispatcher.getDispatcher().getEventQueue());
            // this will start the SerialConnector thread and start listening for incoming measurements
            MeasurementManager man = new MeasurementManager(conf);
            EventDispatcher.getDispatcher().addEventListener(MeasurementEvent.class, man);

            // this initializes the object with the passed arguments, but doesn't do much else 
            RelateAuthenticationProtocol r = new RelateAuthenticationProtocol(serialPort, man, useJSSEServer, false, null);
            // register the listeners
            TempAuthenticationEventHandler ht = new TempAuthenticationEventHandler(1, deviceType);
            r.addAuthenticationProgressHandler(ht);
        	// and start....
            r.startListening();
            //new BufferedReader(new InputStreamReader(System.in)).readLine();

            while (true) Thread.sleep(1000);

            //h1.stopListening();
        } 
        else if (args.length > 5 && args[0].equals("client")) {
        	System.out.println("starting client mode: port=" + args[1] + ", devicetype=" + args[2] + ", server=" + args[3] + ", remoteid=" + args[4] + ", rounds=" + args[5]);
        	String serialPort = args[1];
        	final int deviceType = Integer.parseInt(args[2]);
        	logger.info("Starting client mode");
        	Configuration conf = new Configuration(serialPort, deviceType);
        	SerialConnector connector = SerialConnector.getSerialConnector(conf.getDevicePortName(), conf.getDeviceType());
        	connector.registerEventQueue(EventDispatcher.getDispatcher().getEventQueue());
            // this will start the SerialConnector thread and start listening for incoming measurements
            MeasurementManager man = new MeasurementManager(conf);
            EventDispatcher.getDispatcher().addEventListener(MeasurementEvent.class, man);
            
        	RelateAuthenticationProtocol r = new RelateAuthenticationProtocol(serialPort, man, useJSSEClient, false, null);
        	TempAuthenticationEventHandler t = new TempAuthenticationEventHandler(0, deviceType);
        	r.addAuthenticationProgressHandler(t);
        	r.startAuthentication(args[3], Integer.parseInt(args[4]), Integer.parseInt(args[5]));
            // This is the last safety belt: a timer to kill the client if the dongle hangs for some reason. This is
            // not so simple for the server.
            new Thread(new Runnable() {
            	public void run() {
            		System.out.println("******** Starting timer");
            		// two minutes should really be enough
            		try {
            			Thread.sleep(120 * 1000);
            		} catch (InterruptedException e) {
            			// just ignore, it doesn't matter too much if it's shorter
            		}
            		System.out.println("******** Timed out");
        			statisticsLogger.error("- Timer killed client");
   	        		resetBothDongles(deviceType);
   	        		if (! System.getProperty("os.name").startsWith("Windows CE"))
   	        			System.exit(100);
            	}
            }).start();

            //new BufferedReader(new InputStreamReader(System.in)).readLine();

            if (TempAuthenticationEventHandler.useProgressBar) {
            	while (! ((org.eclipse.swt.widgets.Shell) t.s).isDisposed()) {
            		if (((org.eclipse.swt.widgets.Display) t.d).readAndDispatch())
            			((org.eclipse.swt.widgets.Display) t.d).sleep();
            	}
            }
            else
                while (true) Thread.sleep(1000);
        }
        else if (args.length == 6 && args[0].equals("both")) {
        	logger.info("Starting mutual authentication mode with two dongles");
        	int localId1 = -1, localId2 = -1;
        	String serialPort1 = args[1], serialPort2 = args[3];
        	int deviceType1 = Integer.parseInt(args[2]), deviceType2 = Integer.parseInt(args[4]);

        	Configuration conf1 = new Configuration(serialPort1, deviceType1);
        	Configuration conf2 = new Configuration(serialPort2, deviceType2);
        	// first need to get my local ids
        	try {
            	SerialConnector connector1 = SerialConnector.getSerialConnector(conf1.getDevicePortName(), conf1.getDeviceType());
        		localId1 = connector1.getLocalRelateId();
            	connector1.registerEventQueue(EventDispatcher.getDispatcher().getEventQueue());

        		Thread.sleep(deviceType1 == 1 ? 1000 : 500);

            	SerialConnector connector2 = SerialConnector.getSerialConnector(conf2.getDevicePortName(), conf2.getDeviceType());
        		localId2 = connector2.getLocalRelateId();
            	connector2.registerEventQueue(EventDispatcher.getDispatcher().getEventQueue());
        	}
        	catch (DeviceException e) {
        		logger.error("-------- failed to connect to dongle, didn't get my ID.");
        		System.out.println(e);
        		//e.printStackTrace();
        		if (! System.getProperty("os.name").startsWith("Windows CE"))
        			System.exit(1);
        	}

        	logger.info("Connected to my two dongles: ID " + localId1 + " on " + serialPort1 + ", and ID " + localId2 + " on " + serialPort2);

            MeasurementManager man1 = new MeasurementManager(conf1);
            EventDispatcher.getDispatcher().addEventListener(MeasurementEvent.class, man1);
            MeasurementManager man2 = new MeasurementManager(conf2);
            EventDispatcher.getDispatcher().addEventListener(MeasurementEvent.class, man2);
        		
        	// server side
        	TempAuthenticationEventHandler ht = new TempAuthenticationEventHandler(2, deviceType1);
            RelateAuthenticationProtocol r_serv = new RelateAuthenticationProtocol(serialPort1, man1, useJSSEServer, false, null);
            r_serv.addAuthenticationProgressHandler(ht);
            r_serv.startListening();

            // client side
            RelateAuthenticationProtocol r_client = new RelateAuthenticationProtocol(serialPort2, man2, useJSSEClient, false, null);
        	r_client.addAuthenticationProgressHandler(ht);
        	r_client.startAuthentication("localhost", localId1, Integer.parseInt(args[5]));
        	
        	// safety belt
            new Thread(new Runnable() {
            	public void run() {
            		System.out.println("******** Starting timer");
            		// two minutes should really be enough
            		try {
            			Thread.sleep(120 * 1000);
            		} catch (InterruptedException e) {
            			// just ignore, it doesn't matter too much if it's shorter
            		}
            		System.out.println("******** Timed out");
            		statisticsLogger.error("- Timer killed client");
            		if (! System.getProperty("os.name").startsWith("Windows CE"))
            			System.exit(100);
            		}
            	}).start();

            // and wait
            while (true) Thread.sleep(1000);
        }
        else {
        	System.err.println("Usage: RelateAuthenticationProtocol server <port> <device type>");
        	System.err.println("                                    client <port> <device type> <remote IP> <remote ID> <rounds>");
        	System.err.println("                                    both <port 1> <device type 1> <port 2> <device type 2> <rounds>");
        	System.err.println();
        	System.err.println("Device type is 1 for dongles, 2 for bricks");
        }
        
        // problem with the javax.comm API - doesn't release its native thread
        if (! System.getProperty("os.name").startsWith("Windows CE"))
       		System.exit(0);
	}
}
